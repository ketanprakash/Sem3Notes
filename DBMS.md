# Database Management System

## 2021-08-16

### Introduction to the Course

**Grading Scheme**
1. 1 Minor
1. 1 Major
1. 2 Quiz
1. Mini Project

**No marks for attendance but all quizes will be surprise quizes.**

**Slides will be used for teaching**

**DBMS Lab Course**
1. 3 Assignments
1. Mini Project from the theory course

**If medical emergency, email sir before class**

Recommended Book: [Database System Concepts](https://docs.google.com/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxlaW1yYWxla3lvc2hpdHN1fGd4OjVkMDk1OTc0YTZkYTAzOTM)

**[Slides](https://drive.google.com/drive/folders/1LVNF2cJZdfp9bMcboPE2lLkVLoYEYHul?usp=sharing)**
1. [Introduction](https://docs.google.com/presentation/d/1cYTunog75xwgB5kjV4bWZHtRVjuY5SYz/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

2. [Introduction to the Relational Model](https://docs.google.com/presentation/d/1MZILpH5NNZL13utCLEwmevJuFHqHP3Wg/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)	

3. [Introduction to SQL](https://docs.google.com/presentation/d/1m-rNGP-_TTHXKNc-dCN4iW7vo1-gVRW5/edit#slide=id.p1)

4. [Intermediate SQL](https://docs.google.com/presentation/d/1HurNhZVwup_v07K_h_ZOlwNCNnZaSaW4/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

5. [Advanced SQL](https://docs.google.com/presentation/d/1bDDenkz1hgbr-GANaCmE7Wa7kDMgwkYq/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

6. [Formal Relational Query Languages](https://docs.google.com/presentation/d/1Nif-BEjn9rpOsscNnf8SpF9y799GgtoR/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

7. [Database Design: The Entity-Relationship Approach](https://docs.google.com/presentation/d/1jYrb8JV8I1iu6QmpluhRHc6MaDWwxBuZ/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)	

8. [Relational Database Design](https://docs.google.com/presentation/d/1KVWbU1BohzNXOinbZHEsBJMe_kJ-ZP38/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)	

9. [Application Design](https://docs.google.com/presentation/d/1w-_8nkaOg9ZMcnc5pi0iWdXUR1bZ3-z_/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

10. [Storage and File Structure](https://docs.google.com/presentation/d/1BMTCZs33aNOAhQfNQ5epVQ1uWlfi2YSi/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

11. [Indexing and Hashing](https://docs.google.com/presentation/d/12B5PvPVoZ_cA9phOxtH6mpYPy0_ySjyz/edit?usp=sharing&ouid=107556050169885649329&rtpof=true&sd=true)

12. [Query Processing](https://docs.google.com/presentation/d/1LYoJQvYrRt0sFvptX6r23GNDbPxbAqZ2/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)	

13. [Query Optimization](https://docs.google.com/presentation/d/1JIDjQ25AtmFImyGxABOQvy3UDY6n8I5S/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)	

14. [Transactions](https://docs.google.com/presentation/d/1U0sqLHj6OFsDgd1lXpS7MFSCnNYfc8Pa/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

15. [Concurrency Control](https://docs.google.com/presentation/d/1jcK7R01_-O6ByMFnI0MsstUVDf29V7v0/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

16. [Recovery System](https://docs.google.com/presentation/d/12lvEudOcf4Ujp5r6bCzpf1sV2Vvzy1YF/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

17. [Database System Architectures](https://docs.google.com/presentation/d/1-olFfkgmjTiimbwImQsIHqEe1veDlrgR/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

18. [Parallel Databases](https://docs.google.com/presentation/d/1xP8fxhLFWK1UJ42TMMimmniyH6TvldJw/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

19. [Distributed Databases](https://docs.google.com/presentation/d/1E9ykeFUVPJWEe8z5j-TBcAKFprOrZfqc/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

20. [Data Mining](https://docs.google.com/presentation/d/1RaMDviNK_dLlM0WX17LPMkFoCxw551Ji/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

21. [Information Retrieval](https://docs.google.com/presentation/d/18paP7kURG7wE-fuzS43VnPrQmYzErESP/edit)

22. [Object-Based Databases](https://docs.google.com/presentation/d/1IKdX_XHrVtCictrsnDQYwU0z7vknP5Bp/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)	

23. [XML](https://docs.google.com/presentation/d/1xoVnJYe8fd59_FR0e9QVx-AVgmt0Rspu/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

24. [Advanced Application Development](https://docs.google.com/presentation/d/1pA7oeesDFWx8QRYhh9t1JwGm-saJsXqE/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)

25. [Advanced Data Types](https://docs.google.com/presentation/d/1gJK1vJgRj3ErZXUA102RPHNT-6bRoHFz/edit?usp=drive_web&ouid=107556050169885649329&rtpof=true)	

26. [Advanced Transaction Processing](https://docs.google.com/presentation/d/1gO9obR6XekClISxjWGQUbGkYA5faUs0s/edit#slide=id.p1)

## Relational Algebra Practice

(relational algebra notebook images)

## Joins in SQL

* Natural Join
    * Eg: 
        * There are following schemas:
            * section(course_id, section_id, semester, year, building, room_no)
            * instructor(id, name, dept_name, salary)
            * teaches(id, course_id, section_id, semester, year)
            * course(course_id, title, dept_name, credits)
            * department(dept_name, building, budget)
        * Find the name of instructor and course_id of all courses taught by an instructor
        * Ans:
            * SELECT name, course_id
            * FROM instructor, teaches
            * WHERE instructor.id = teaches.id;
            * ![(image)](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20210920_115526_OHYDVul4r.png?updatedAt=1632119159637)
            * SELECT name, course_id
            * FROM instructor NATURAL JOIN teaches;
            * ![(image)](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20210920_115654_7URxGFTqu.png?updatedAt=1632119237593)

        * List the name of instructor along with the title of the course that they teach
        * Ans: 
            * SELECT name, title
            * FROM instructor NATURAL JOIN teaches NATURAL JOIN course;
            * ![(image)](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20210920_115809_EawQJxVe1.png?updatedAt=1632119314071)

            * Problem with the instructor: If the a course is taught by an instructor from a different department this query does not work, problem is that there are two different overlapping attributes dept_name and course_id

            * SELECT name, title
            * FROM (instructor NATURAL JOIN teaches) JOIN course
            * USING (course_id);
            * ![(image)](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20210920_120231_pfqOdUarv.png?updatedAt=1632119582840)

* ON
    * The ON clause allows a general predicate over the joined relation
    * Eg:
        * SELECT *
        * FROM student JOIN takes
        * ON student.id = takes.id
        * WHERE name like 'Z?';
        * ![(image)](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20210920_120428_c5nGB9ofu.png?updatedAt=1632119690491)

## 2021-10-27

### Canonical Cover

* Def: A canonical cover F<sub>c</sub> on F will contain no extraneous(redundant) FDs.

* If F<sub>c</sub> contains A <span class = "ligature">-></span> B, B <span class = "ligature">-></span> C, then it won't contain A <span class = "ligature">-></span> C

* Algo
    * F<sub>c</sub> = F
    * do 
    * Union Rule: a<sub>1</sub> <span class = "ligature">-></span> b<sub>1</sub>, a<sub>2</sub> <span class = "ligature">-></span> b<sub>2</sub>, replace with a<sub>1</sub> <span class = "ligature">-></span> b<sub>1</sub>b<sub>2</sub>
    * Find a <span class = "ligature">-></span> b in F<sub>c</sub> with extraneous attribute in a or b
    * If an extraneous attribute is found, delete it from a <span class = "ligature">-></span> b

* Finding if an attribute is redundant in a <span class = "ligature">-></span> b
    * We remove the attribute from the FD and then find a<sup>+</sup>, if it stays the same, then the attribute is redundant
    * eg: 
        * name <span class = "ligature">-></span> roll, cgpa
        * roll <span class = "ligature">-></span> cgpa

        * now, name<sup>+</sup> = {roll, cgpa}
        * if we remove cgpa, new FD name <span class = "ligature">-></span> roll
        * name<sup>+</sup> = {roll, cgpa}
        * since name<sup>+</sup> does not change, cgpa is redundant

* Algo
    * Consider FD a <span class = "ligature">-></span> b in F and attribute A is extraneous:
        * If A belongs to a, F' = (F - {a <span class = "ligature">-></span> b}) U ((a - A) <span class = "ligature">-></span> b)
        * If F <span class = "ligature">=></span> F', then the attribute is extraneous else it is not extraneous

        * If A belongs to a, F' = (F - {a <span class = "ligature">-></span> b}) U ((a - A) <span class = "ligature">-></span> b)
        * If F' <span class = "ligature">=></span> F then the attribute is extraneous else it is not extraneous

    * Eg: F = {A <span class = "ligature">-></span> BC, B <span class = "ligature">-></span> C, AB <span class = "ligature">-></span> C, A <span class = "ligature">-></span> B}. Find the Canonical Cover
        * Using Union Rule: Combining A <span class = "ligature">-></span> BC and A <span class = "ligature">-></span> B, we get A <span class = "ligature">-></span> BC
        * F = {A <span class = "ligature">-></span> BC, B <span class = "ligature">-></span> C, AB <span class = "ligature">-></span> C}
        * F = {A <span class = "ligature">-></span> BC, B <span class = "ligature">-></span> C, B <span class = "ligature">-></span> C}

        * Does F <span class = "ligature">=></span> F' ? Yes, because F' is a subset of F

## 2021-10-29
### Canonical Covers

* R(w, x, y, z), F = {x <span class = "ligature">-></span> w, wz <span class="ligature">-></span> xy, y <span class = "ligature">-></span> wxz}, What is Fc?
* Solution:
    * Remove redundancy in RHS using decomposition
        * F = {x <span class = "ligature">-></span> w, <s>wz <span class = "ligature">-></span> x</s>, wz <span class = "ligature">-></span> y, y <span class = "ligature">-></span> x, <s>y <span class = "ligature">-></span> w</s>, y <span class = "ligature">-></span> z}
    
    * Remove redundancy in entire rule: 
        * Check for x <span class = "ligature">-></span> w: 
            * x<sup>+</sup> = {x, w}, 
            * (not considering this rule)(x<sup>+</sup>)' = {x}
            * So this rule is not redundant 
        * Check for wz <span class = "ligature">-></span> x
            * wz<sup>+</sup>: {w, z, x, y}
            * (wz<sup>+</sup>)': {w, z, y, x}
            * So this is redundant
        * Check for wz <span class = "ligature">-></span> y
            * wz<sup>+</sup> = {w, z, y, x}
            * (wz<sup>+</sup>)' = {w, z}
            * So this rule is not redundant
        * y <span class = "ligature">-></span> x
            * y<sup>+</sup> = {y, x, w, z}
            * (y<sup>+</sup>)' = {y, w, z}
            * Essential
        * y <span class = "ligature">-></span> w:
            * y<sup>+</sup> = {y, x, w, z}
            * (y<sup>+</sup>)' = {y, x, w, z}
            * Redundant
        * y <span class = "ligature">-></span> z: 
            * y<sup>+</sup> = {y, x, w, z}
            * (y<sup>+</sup>)' = {y, x, w}
            * Essential
    * F: {x <span class = "ligature">-></span> w, wz <span class = "ligature">-></span> y, y <span class = "ligature">-></span> x, y <span class = "ligature">-></span> z}
    * Remove redundancy on the left hand side:
        * Checking wz <span class = "ligature">-></span> y
            * wz<sup>+</sup> = {w, z, y, x}
            * w<sup>+</sup> = {w}
            * z<sup>+</sup> = {z}
            * Both w and z are essential since the w<sup>+</sup> and z<sup>+</sup> <span class = "ligature">!=</span> (wz)<sup>+</sup>
    * Use union to combine rules:
        * F<sub>c</sub> = {x <span class = "ligature">-></span> w, wz <span class = "ligature">-></span> y, y <span class = "ligature">-></span> xz}
        * F = {x <span class = "ligature">-></span> w, wz <span class = "ligature">-></span> xy, y <span class = "ligature">-></span> wxz}
> If w<sup>+</sup> = {w, z, x, y}, in that case z would have been redundant
> If z<sup>+</sup> = {w, z, x, y}, in that case w would have been redundant

### Lossless Join Decomposition
* If R is decomposed into (R1, R2) it would be lossless if the following conditions hold:
    1. a(R1) U a(R2) = a(R): Every attribute of R must be in either R1 or R2 or both
    1. a(R1) ∩ a(R2) <span class = "ligature">!=</span> ϕ: There must be a common attribute in R1 and R2
    1. a(R1) ∩ a(R2) <span class = "ligature">-></span> a(R1) or a(R1) ∩ a(R2) <span class = "ligature">-></span> a(R2): The common attribute must be a candidate key of either R1 or R2

* Practice
    * ![Question Image](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20211029_115548_dwvFFMyS1xk.png?updatedAt=1635587777008)

    * ![Soln Image 1](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20211029_120136_6s5EgAMBk.png?updatedAt=1635587777817)
    * ![Soln Image 2](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20211029_120151_ODPPKK0WN.png?updatedAt=1635587778605)

> Learn about Dependency Preseving Decomposition

## 2021-11-01

* What is a 'good' decomposition?

1. **1NF**
    * Ensure that every attribute in the schema is atomic
    * Automatically assume every attribute to be "ATOMIC"
    * Student(roll, name, class)

1. **2NF(Second Normal Form)**
    * Table should be in 1NF
    * No **partial dependency**: Some non-prime attributes are not fully dependent on the primary key
        * Eg: R(A,B,C,D,E)
            * Non prime C, D, E, AB <span class="ligature">-></span> C, (A <span class="ligature">-></span> C(partial dependency))
            * Non prime attribute is dependent on part of primary key
    * Example
        * ![Example Image](https://ik.imagekit.io/ketanprakash001/NotesAssets/Screenshot_20211101_112620_HcX-nOYA3XP.png?updatedAt=1636299806858)
        * If Primary key is {student Id, Subject Id}, then {Student Id, Subject Id} <span class="ligature">-></span> Teacher
        * Also, Subject Id <span class="ligature">-></span> Teacher
        * Therefore, Teacher is dependent on a part of Primary Key, therefore, Subject ID <span class="ligature">-></span> Teacher is a partial dependency
        * We need to break the Score schema into two parts: SCORE and SUBJECT
        * SCORE(score id, student id, subject Id, marks)
        * SUBJECT(subject id, teacher) 
    
    * Example: 
        * Grade_Report(Sid, Sname, addr, major, cid, ctitle, fname, floc, grade)

        * Functional Dependencies
            * sid, cid <span class="ligature">-></span> Grade Report
            * Sid <span class="ligature">-></span> Sname, addr, major
            * cid <span class="ligature">-></span> ctitle, fname, floc
            * fname <span class="ligature">-></span> floc
            * sid, cid <span class="ligature">-></span> grade

            * 3 Tables: 
                * T1(sid, cid, grade)
                * T2(sid, sname, addr, major)
                * T3(cid, ctitle, fname, floc)

        * T1, T2, T3, are in 2NF

        * If the primary key is not composite(single attribute), the table is always in 2NF

1. **3NF(Third Normal Form)**
    * Conditions: 
        1. Relation is in 2NF
        1. There should be no transitive dependency for non prime attributes
            * Transitive dependency: a -> b, b -> c then a -> c where c is non prime
            * In the prev example:
                * T1(sid, cid, grade), T2(sid, sname, addr, major), T3(cid, title, fname, floc)
                * In schema T3, cid -> fname, floc -> fname, cid -> floc is a transient dependency on non prime attribute. Therefore, T3 is not in 3NF
                * Insertion anomaly in T3, we cannot add a faculty if a course is not assigned
                * Deletion anomaly in T3, if a faculty teaches one course and the course is dropped we have to also delete the faculy
                * Updation anomaly in T3, if a faculty changes location, we have to change location in every course table
                * Student(sid, sname, addr, major) -> 3NF, reg(sid, cid, grade) -> 3NF, Course(cid, title, fname, floc) -> Not in 3NF
                * cid -> title, fname, floc, fname -> floc
                * Course => C1(**cid**, title, fname), C2(**fname**, floc), "fname" becomes the foreign key
                * A foreign key is natural outcome of 3NF decomposition
    
    * OR

    * 2nd Definition: A relation in 3NF if for all a -> b in F atleast one of the following conditions hold:
        1. a -> b is trivial (b ⊆ a)
        1. a is a superkey
        1. Each attribute 'A' in (b - a) should be prime
            * fname -> floc does not follow any of the three conditions
    1. Lossless Decomposition upto 3NF
    1. Dependency preserving

1. **Boyce - Codd Normal Form**
    * Eg: 
        * ![Question Image]()
        * Criterion:
            1. For a single subject, there can be multiple registered students
            1. A student can register for multiple subjects
            1. A subject can have multiple faculties
            1. A faculty can teach only one subject
            1. For a single subject, a student can be taught by a single faculty
        * Functional Dependencies:
            1. Advisor -> Major
            1. SID, Major -> Advisor
        * Candidate Key: <u>SID</u>, <u>Major</u>
        * Check for 1NF: Atomic by default
        * Check for 2NF: No partial dependency
        * Check for 3NF: It is in 3NF
        * Deletion Anomaly: Present as we lose the info that F4 teaches Phy
        * Insertion Anomaly: We cannot insert a new advisor and major without a student registration
    * Left Hand Side should of every functional dependency should be a prime attribute
    * If we delete the third criteria from 3NF is BCNF
    * Decomposition Algorithm:
        * Suppose we have schema R and a non - trivial FD a -> b which causes a violation of BCNF, we can decompose it as
            1. a U b
            1. (R - (b - a))
    * Eg:  
        * After Decomposition
            1. R1(<u>Advisor</u>, Major)
            1. R2(<u>SID, Advisor</u>)
    * After BCNF, there is not insertion, upadation and deletion anomaly